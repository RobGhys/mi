<!DOCTYPE html>

<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>1_core_maths</title>
<style>
        /* Theme */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem;
        }

        /* Navigation */
        .nav-container {
            background-color: #f8f9fa;
            padding: 1rem;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 1000;
        }
        .nav-container h1 {
            margin: 0 0 1rem 0;
            color: #333;
        }
        .nav-links {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }
        .nav-links a {
            text-decoration: none;
            color: #0366d6;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        .nav-links a:hover {
            background-color: #e1e4e8;
        }
        .nav-links a.active {
            background-color: #0366d6;
            color: white;
        }

        /* Notebook content */
        .notebook-content {
            padding: 2rem 0;
        }
        
        .cell {
            margin: 1rem 0;
        }
        
        .input_area pre {
            background-color: #f6f8fa;
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
        }
        
        .output_area pre {
            padding: 1rem;
            border-left: 3px solid #0366d6;
            background-color: #f8f9fa;
        }

        img {
            max-width: 100%;
            height: auto;
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 1rem;
            background-color: #f8f9fa;
            margin-top: 2rem;
            font-size: 0.9rem;
            color: #666;
            border-top: 1px solid #e1e4e8;
        }
    </style>
</head><body>
<div class="nav-container">
<h1>Mechanistic Interpretability Tutorial</h1>
<nav class="nav-links">
<a href="../../docs/index.html">Home</a>
<div class="nav-section">
<a class="active" href="../1_maths/1_core_maths.html">Core Maths</a>
<a href="../1_maths/2_advanced_maths.html">Advanced Maths</a>
<a href="../1_maths/3_probas.html">Probability</a>
<a href="../1_maths/4_calculus.html">Calculus</a>
</div>
<div class="nav-section">
<a href="../2_numpy/1_np_tuto.html">NumPy</a>
</div>
<div class="nav-section">
<a href="../3_nn/micrograd.html">Neural Networks</a>
</div>
</nav>
</div>
<div class="notebook-content">
<div class="cell markdown_cell"><h1 id="1.-Basis">1. Basis<a class="anchor-link" href="#1.-Basis">¶</a></h1></div>
<div class="cell code_cell"><div class="input_area">
<pre>import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D</pre>
</div></div>
<div class="cell markdown_cell"><p>'''</p>
<h1 id="Understanding-Basis-in-Linear-Algebra">Understanding Basis in Linear Algebra<a class="anchor-link" href="#Understanding-Basis-in-Linear-Algebra">¶</a></h1><h2 id="Definition">Definition<a class="anchor-link" href="#Definition">¶</a></h2><p>A basis is a set of vectors that satisfy two fundamental properties:</p>
<ol>
<li>Linear Independence</li>
<li>Span</li>
</ol>
<p>Let's formalize this mathematically:</p>
<h3 id="Linear-Independence">Linear Independence<a class="anchor-link" href="#Linear-Independence">¶</a></h3><p>A set of vectors $\{v_1, v_2, ..., v_n\}$ is linearly independent if the equation:</p>
<p>$c_1v_1 + c_2v_2 + ... + c_nv_n = 0$</p>
<p>has only the trivial solution $c_1 = c_2 = ... = c_n = 0$</p>
<h3 id="Span">Span<a class="anchor-link" href="#Span">¶</a></h3><p>The span of a set of vectors is all possible linear combinations of those vectors:</p>
<p>$span\{v_1, v_2, ..., v_n\} = \{c_1v_1 + c_2v_2 + ... + c_nv_n : c_i \in \mathbb{R}\}$</p>
<h3 id="Formal-Definition">Formal Definition<a class="anchor-link" href="#Formal-Definition">¶</a></h3><p>A basis for a vector space $V$ is a linearly independent set of vectors that spans $V$.</p>
<h2 id="Standard-Basis">Standard Basis<a class="anchor-link" href="#Standard-Basis">¶</a></h2><p>The most common basis in $\mathbb{R}^n$ is the standard basis. For example:</p>
<p>In $\mathbb{R}^2$:
$e_1 = \begin{pmatrix} 1 \\ 0 \end{pmatrix}, e_2 = \begin{pmatrix} 0 \\ 1 \end{pmatrix}$</p>
<p>In $\mathbb{R}^3$:
$e_1 = \begin{pmatrix} 1 \\ 0 \\ 0 \end{pmatrix}, 
e_2 = \begin{pmatrix} 0 \\ 1 \\ 0 \end{pmatrix},
e_3 = \begin{pmatrix} 0 \\ 0 \\ 1 \end{pmatrix}$
'''</p>
</div>
<div class="cell code_cell"><div class="input_area">
<pre>plt.figure(figsize=(10, 10))
plt.quiver([0, 0], [0, 0], [1, 0], [0, 1], angles='xy', scale_units='xy', scale=1, color=['r', 'b'])
plt.xlim(-0.5, 1.5)
plt.ylim(-0.5, 1.5)
plt.grid(True)
plt.title('Standard Basis Vectors in R²')
plt.xlabel('x')
plt.ylabel('y')
plt.axhline(y=0, color='k', linestyle='-', alpha=0.3)
plt.axvline(x=0, color='k', linestyle='-', alpha=0.3)
plt.show()</pre>
</div><div class="output_area"></div></div>
<div class="cell markdown_cell"><h1 id="Comprehensive-Understanding-of-Vector-Space-Basis">Comprehensive Understanding of Vector Space Basis<a class="anchor-link" href="#Comprehensive-Understanding-of-Vector-Space-Basis">¶</a></h1><h2 id="1.-Fundamental-Concepts">1. Fundamental Concepts<a class="anchor-link" href="#1.-Fundamental-Concepts">¶</a></h2><h3 id="1.1-Linear-Independence">1.1 Linear Independence<a class="anchor-link" href="#1.1-Linear-Independence">¶</a></h3><p>A set of vectors $\{v_1, v_2, ..., v_n\}$ is linearly independent if no vector in the set can be expressed as a linear combination of the others.</p>
<p>Mathematically, if:
$c_1v_1 + c_2v_2 + ... + c_nv_n = 0$</p>
<p>Then $c_1 = c_2 = ... = c_n = 0$ is the only solution.</p>
<h4 id="Examples:">Examples:<a class="anchor-link" href="#Examples:">¶</a></h4><ol>
<li><p>In $\mathbb{R}^2$:</p>
<ul>
<li>Vectors $\begin{pmatrix} 1 \\ 0 \end{pmatrix}$ and $\begin{pmatrix} 0 \\ 1 \end{pmatrix}$ are linearly independent</li>
<li>Vectors $\begin{pmatrix} 1 \\ 1 \end{pmatrix}$ and $\begin{pmatrix} 2 \\ 2 \end{pmatrix}$ are linearly dependent (second is multiple of first)</li>
</ul>
</li>
<li><p>In $\mathbb{R}^3$:</p>
<ul>
<li>Standard basis vectors are linearly independent</li>
<li>Any set of four vectors in $\mathbb{R}^3$ is always linearly dependent</li>
</ul>
</li>
</ol>
<h3 id="1.2-Span">1.2 Span<a class="anchor-link" href="#1.2-Span">¶</a></h3><p>The span of vectors is all possible linear combinations of those vectors.</p>
<p>For vectors $v_1, v_2, ..., v_n$:
$span\{v_1, v_2, ..., v_n\} = \{c_1v_1 + c_2v_2 + ... + c_nv_n : c_i \in \mathbb{R}\}$</p>
<p>Let's visualize span in $\mathbb{R}^2$:</p>
</div>
<div class="cell code_cell"><div class="input_area">
<pre>def visualize_span():
    # Create vectors
    v1 = np.array([1, 0])
    v2 = np.array([0.5, 0.866])  # 60-degree angle
    
    # Create grid of coefficients
    c1 = np.linspace(-2, 2, 20)
    c2 = np.linspace(-2, 2, 20)
    C1, C2 = np.meshgrid(c1, c2)
    
    # Calculate points in span
    X = C1*v1[0] + C2*v2[0]
    Y = C1*v1[1] + C2*v2[1]
    
    # Plot
    plt.figure(figsize=(12, 6))
    
    # Left plot: vectors
    plt.subplot(121)
    plt.quiver([0, 0], [0, 0], [v1[0], v2[0]], [v1[1], v2[1]], 
               angles='xy', scale_units='xy', scale=1, color=['r', 'b'])
    plt.xlim(-2, 2)
    plt.ylim(-2, 2)
    plt.grid(True)
    plt.title('Basis Vectors')
    plt.axis('equal')
    
    # Right plot: span
    plt.subplot(122)
    plt.scatter(X, Y, c='g', alpha=0.3, s=10)
    plt.quiver([0, 0], [0, 0], [v1[0], v2[0]], [v1[1], v2[1]], 
               angles='xy', scale_units='xy', scale=1, color=['r', 'b'])
    plt.xlim(-2, 2)
    plt.ylim(-2, 2)
    plt.grid(True)
    plt.title('Span of Vectors')
    plt.axis('equal')
    
    plt.tight_layout()
    plt.show()

visualize_span()</pre>
</div><div class="output_area"></div></div>
<div class="cell markdown_cell"><h2 id="2.-Properties-of-Basis">2. Properties of Basis<a class="anchor-link" href="#2.-Properties-of-Basis">¶</a></h2><h3 id="2.1-Key-Properties">2.1 Key Properties<a class="anchor-link" href="#2.1-Key-Properties">¶</a></h3><ol>
<li><p><strong>Minimal Spanning Set</strong></p>
<ul>
<li>A basis is a minimal set of vectors that spans the space</li>
<li>Removing any vector from the basis makes it impossible to span the space</li>
</ul>
</li>
<li><p><strong>Maximal Linearly Independent Set</strong></p>
<ul>
<li>A basis is a maximal set of linearly independent vectors</li>
<li>Adding any vector to the basis creates linear dependence</li>
</ul>
</li>
<li><p><strong>Unique Representation</strong></p>
<ul>
<li>Every vector in the space has a unique representation as a linear combination of basis vectors</li>
<li>These coefficients are called coordinates in that basis</li>
</ul>
</li>
</ol>
<h3 id="2.2-Dimension">2.2 Dimension<a class="anchor-link" href="#2.2-Dimension">¶</a></h3><p>The number of vectors in a basis is called the dimension of the vector space.</p>
<p>Important facts:</p>
<ol>
<li>All bases of a vector space have the same number of vectors</li>
<li>This number is unique to the vector space</li>
<li>We denote the dimension of a space $V$ as $dim(V)$</li>
</ol>
<p>Let's verify this with code:</p>
</div>
<div class="cell code_cell"><div class="input_area">
<pre>def demonstrate_dimension():
    # Create different bases for R²
    basis1 = np.array([[1, 0], [0, 1]])  # Standard basis
    basis2 = np.array([[1, 1], [-1, 1]])  # Another basis
    basis3 = np.array([[2, 1], [-1, 1]])  # Another basis
    
    # Function to check if vectors are linearly independent
    def is_independent(vectors):
        return np.linalg.matrix_rank(vectors) == len(vectors)
    
    # Function to visualize basis vectors
    def plot_basis(basis, title):
        plt.quiver([0, 0], [0, 0], basis[:, 0], basis[:, 1], 
                  angles='xy', scale_units='xy', scale=1, color=['r', 'b'])
        plt.xlim(-2, 2)
        plt.ylim(-2, 2)
        plt.grid(True)
        plt.title(title)
        plt.axis('equal')
    
    # Plot different bases
    plt.figure(figsize=(15, 5))
    
    plt.subplot(131)
    plot_basis(basis1, 'Standard Basis')
    
    plt.subplot(132)
    plot_basis(basis2, '45° Rotated Basis')
    
    plt.subplot(133)
    plot_basis(basis3, 'Skewed Basis')
    
    plt.tight_layout()
    plt.show()
    
    # Print independence information
    print(f"Standard basis independent: {is_independent(basis1)}")
    print(f"Rotated basis independent: {is_independent(basis2)}")
    print(f"Skewed basis independent: {is_independent(basis3)}")

demonstrate_dimension()</pre>
</div><div class="output_area"><pre>Standard basis independent: True
Rotated basis independent: True
Skewed basis independent: True
</pre></div></div>
<div class="cell markdown_cell"><h2 id="3.-Different-Types-of-Bases">3. Different Types of Bases<a class="anchor-link" href="#3.-Different-Types-of-Bases">¶</a></h2><h3 id="3.1-Standard-Basis">3.1 Standard Basis<a class="anchor-link" href="#3.1-Standard-Basis">¶</a></h3><p>The standard basis in $\mathbb{R}^n$ consists of vectors with a 1 in one position and 0s elsewhere:</p>
<p>$e_1 = \begin{pmatrix} 1 \\ 0 \\ \vdots \\ 0 \end{pmatrix}, 
e_2 = \begin{pmatrix} 0 \\ 1 \\ \vdots \\ 0 \end{pmatrix}, 
..., 
e_n = \begin{pmatrix} 0 \\ 0 \\ \vdots \\ 1 \end{pmatrix}$</p>
<h3 id="3.2-Orthogonal-and-Orthonormal-Bases">3.2 Orthogonal and Orthonormal Bases<a class="anchor-link" href="#3.2-Orthogonal-and-Orthonormal-Bases">¶</a></h3><p>An orthogonal basis consists of vectors that are perpendicular to each other:
$v_i \cdot v_j = 0$ for $i \neq j$</p>
<p>An orthonormal basis is an orthogonal basis where all vectors have unit length:
$v_i \cdot v_j = \delta_{ij}$ (Kronecker delta)</p>
<p>Let's create and visualize orthonormal bases:</p>
</div>
<div class="cell code_cell"><div class="input_area">
<pre>def demonstrate_orthonormal():
    # Create orthonormal basis through rotation
    theta = np.pi/4  # 45 degrees
    basis = np.array([
        [np.cos(theta), -np.sin(theta)],
        [np.sin(theta), np.cos(theta)]
    ])
    
    # Verify orthonormality
    print("Dot product of basis vectors:", 
          np.dot(basis[0], basis[1]))
    print("Lengths of basis vectors:", 
          [np.linalg.norm(v) for v in basis])
    
    # Visualize
    plt.figure(figsize=(10, 10))
    plt.quiver([0, 0], [0, 0], basis[:, 0], basis[:, 1], 
               angles='xy', scale_units='xy', scale=1, color=['r', 'b'])
    plt.xlim(-1.5, 1.5)
    plt.ylim(-1.5, 1.5)
    plt.grid(True)
    plt.title('Orthonormal Basis')
    plt.axis('equal')
    
    # Add unit circle
    circle = plt.Circle((0, 0), 1, fill=False, color='g', linestyle='--')
    plt.gca().add_artist(circle)
    
    plt.show()

demonstrate_orthonormal()</pre>
</div><div class="output_area"><pre>Dot product of basis vectors: 0.0
Lengths of basis vectors: [np.float64(1.0), np.float64(1.0)]
</pre></div></div>
<div class="cell markdown_cell"><h2 id="4.-Applications-and-Importance">4. Applications and Importance<a class="anchor-link" href="#4.-Applications-and-Importance">¶</a></h2><h3 id="4.1-Coordinate-Systems">4.1 Coordinate Systems<a class="anchor-link" href="#4.1-Coordinate-Systems">¶</a></h3><p>Different bases provide different ways to represent the same vector:</p>
<p>If $\{v_1, v_2, ..., v_n\}$ is a basis, any vector $w$ can be written uniquely as:
$w = c_1v_1 + c_2v_2 + ... + c_nv_n$</p>
<p>The coefficients $[c_1, c_2, ..., c_n]$ are the coordinates of $w$ in this basis.</p>
<h3 id="4.2-Change-of-Basis">4.2 Change of Basis<a class="anchor-link" href="#4.2-Change-of-Basis">¶</a></h3><p>We can convert coordinates between different bases using change of basis matrices:</p>
<p>If $P$ is the matrix whose columns are the new basis vectors expressed in the old basis:
$[w]_{new} = P^{-1}[w]_{old}$</p>
<h3 id="4.3-Applications">4.3 Applications<a class="anchor-link" href="#4.3-Applications">¶</a></h3><ol>
<li><p><strong>Computer Graphics</strong></p>
<ul>
<li>Different coordinate systems for different purposes</li>
<li>Local vs. global coordinates</li>
<li>Camera transformations</li>
</ul>
</li>
<li><p><strong>Quantum Mechanics</strong></p>
<ul>
<li>Different bases for different observables</li>
<li>Energy basis vs. position basis</li>
</ul>
</li>
<li><p><strong>Signal Processing</strong></p>
<ul>
<li>Fourier basis for frequency analysis</li>
<li>Wavelet basis for time-frequency analysis</li>
</ul>
</li>
</ol>
<p>Let's implement a change of basis example:</p>
</div>
<div class="cell code_cell"><div class="input_area">
<pre>def demonstrate_change_of_basis():
    # Original vector in standard basis
    w = np.array([2, 1])
    
    # New basis (45° rotation)
    theta = np.pi/4
    P = np.array([
        [np.cos(theta), -np.sin(theta)],
        [np.sin(theta), np.cos(theta)]
    ])
    
    # Convert to new basis
    w_new = np.linalg.inv(P) @ w
    
    # Visualize
    plt.figure(figsize=(12, 6))
    
    # Original basis
    plt.subplot(121)
    plt.quiver([0, 0], [0, 0], [1, 0], [0, 1], 
               angles='xy', scale_units='xy', scale=1, color=['r', 'b'])
    plt.quiver(0, 0, w[0], w[1], angles='xy', scale_units='xy', scale=1, 
               color='g', label='Vector')
    plt.xlim(-3, 3)
    plt.ylim(-3, 3)
    plt.grid(True)
    plt.title('Vector in Standard Basis')
    plt.axis('equal')
    
    # New basis
    plt.subplot(122)
    plt.quiver([0, 0], [0, 0], P[:, 0], P[:, 1], 
               angles='xy', scale_units='xy', scale=1, color=['r', 'b'])
    plt.quiver(0, 0, w[0], w[1], angles='xy', scale_units='xy', scale=1, 
               color='g', label=f'Vector: [{w_new[0]:.2f}, {w_new[1]:.2f}]')
    plt.xlim(-3, 3)
    plt.ylim(-3, 3)
    plt.grid(True)
    plt.title('Vector in Rotated Basis')
    plt.axis('equal')
    plt.legend()
    
    plt.tight_layout()
    plt.show()
    
    return w_new

new_coordinates = demonstrate_change_of_basis()</pre>
</div><div class="output_area"></div></div>
<div class="cell markdown_cell"><p>'''</p>
<h2 id="Alternative-Bases">Alternative Bases<a class="anchor-link" href="#Alternative-Bases">¶</a></h2><p>Any set of linearly independent vectors that span the space can serve as a basis. For example, in $\mathbb{R}^2$, we could have:</p>
<p>$v_1 = \begin{pmatrix} 1 \\ 1 \end{pmatrix}, v_2 = \begin{pmatrix} -1 \\ 1 \end{pmatrix}$</p>
<p>This is also a valid basis because:</p>
<ol>
<li>These vectors are linearly independent</li>
<li>They span $\mathbb{R}^2$</li>
</ol>
<p>Let's visualize this alternative basis:
'''</p>
</div>
<div class="cell code_cell"><div class="input_area">
<pre>plt.figure(figsize=(10, 10))
plt.quiver([0, 0], [0, 0], [1, -1], [1, 1], angles='xy', scale_units='xy', scale=1, color=['g', 'm'])
plt.xlim(-1.5, 1.5)
plt.ylim(-1.5, 1.5)
plt.grid(True)
plt.title('Alternative Basis Vectors in R²')
plt.xlabel('x')
plt.ylabel('y')
plt.axhline(y=0, color='k', linestyle='-', alpha=0.3)
plt.axvline(x=0, color='k', linestyle='-', alpha=0.3)
plt.show()</pre>
</div><div class="output_area"></div></div>
<div class="cell markdown_cell"><p>'''</p>
<h2 id="Important-Properties-of-Bases">Important Properties of Bases<a class="anchor-link" href="#Important-Properties-of-Bases">¶</a></h2><ol>
<li><strong>Uniqueness of Representation</strong>: Every vector in the space can be written uniquely as a linear combination of basis vectors.</li>
</ol>
<p>For example, given a vector $w = \begin{pmatrix} 2 \\ 3 \end{pmatrix}$ in $\mathbb{R}^2$, we can write:</p>
<p>$w = 2e_1 + 3e_2$ (in standard basis)</p>
<ol start="2">
<li><p><strong>Dimension</strong>: The number of vectors in a basis is always the same for a given vector space. This number is called the dimension of the space.</p>
</li>
<li><p><strong>Change of Basis</strong>: We can convert coordinates from one basis to another using change of basis matrices.</p>
</li>
</ol>
<p>Let's demonstrate this with code:
'''</p>
</div>
<div class="cell code_cell"><div class="input_area">
<pre>def plot_vector_in_bases(vector, std_basis=True, alt_basis=True):
    plt.figure(figsize=(10, 10))
    
    # Original vector
    plt.quiver(0, 0, vector[0], vector[1], angles='xy', scale_units='xy', scale=1, color='k', label='Vector')
    
    if std_basis:
        # Standard basis vectors
        plt.quiver([0, 0], [0, 0], [1, 0], [0, 1], angles='xy', scale_units='xy', scale=1, 
                  color=['r', 'b'], alpha=0.3, label='Standard Basis')
    
    if alt_basis:
        # Alternative basis vectors
        plt.quiver([0, 0], [0, 0], [1, -1], [1, 1], angles='xy', scale_units='xy', scale=1,
                  color=['g', 'm'], alpha=0.3, label='Alternative Basis')
    
    plt.xlim(-3, 3)
    plt.ylim(-3, 3)
    plt.grid(True)
    plt.title('Vector Representation in Different Bases')
    plt.xlabel('x')
    plt.ylabel('y')
    plt.axhline(y=0, color='k', linestyle='-', alpha=0.3)
    plt.axvline(x=0, color='k', linestyle='-', alpha=0.3)
    plt.legend()
    plt.show()

# Example vector
v = np.array([2, 3])
plot_vector_in_bases(v)</pre>
</div><div class="output_area"></div></div>
<div class="cell markdown_cell"><p>'''</p>
<h2 id="Checking-if-Vectors-Form-a-Basis">Checking if Vectors Form a Basis<a class="anchor-link" href="#Checking-if-Vectors-Form-a-Basis">¶</a></h2><p>To check if a set of vectors forms a basis, we need to verify:</p>
<ol>
<li>Linear independence</li>
<li>Spanning property</li>
</ol>
<p>We can do this by checking the determinant of the matrix formed by these vectors. If the determinant is non-zero, the vectors are linearly independent.</p>
<p>Let's implement this:
'''</p>
</div>
<div class="cell code_cell"><div class="input_area">
<pre>def is_basis(vectors):
    """Check if a set of vectors forms a basis"""
    # Convert to numpy array
    A = np.array(vectors).T
    
    # Check if matrix is square (number of vectors equals dimension)
    if A.shape[0] != A.shape[1]:
        return False
    
    # Check if determinant is non-zero (linear independence)
    return np.abs(np.linalg.det(A)) &gt; 1e-10

# Example usage
vectors1 = [[1, 0], [0, 1]]  # Standard basis
vectors2 = [[1, 1], [1, 1]]  # Not a basis
vectors3 = [[1, 1], [-1, 1]]  # Alternative basis

print(f"Standard basis: {is_basis(vectors1)}")
print(f"Not a basis: {is_basis(vectors2)}")
print(f"Alternative basis: {is_basis(vectors3)}")</pre>
</div><div class="output_area"><pre>Standard basis: True
Not a basis: False
Alternative basis: True
</pre></div></div>
<div class="cell markdown_cell"><h2 id="2.-Change-of-Basis">2. Change of Basis<a class="anchor-link" href="#2.-Change-of-Basis">¶</a></h2><h3 id="Mathematical-Foundation">Mathematical Foundation<a class="anchor-link" href="#Mathematical-Foundation">¶</a></h3><p>A change of basis is a way to convert the coordinates of a vector from one basis to another. Let's say we have:</p>
<ul>
<li>A vector $v$</li>
<li>Two bases $B = \{b_1, ..., b_n\}$ and $B' = \{b'_1, ..., b'_n\}$</li>
<li>Coordinates $[v]_B = (x_1, ..., x_n)$ in basis $B$</li>
<li>Coordinates $[v]_{B'} = (x'_1, ..., x'_n)$ in basis $B'$</li>
</ul>
<p>The change of basis matrix $P_{B \to B'}$ satisfies:</p>
<p>$[v]_{B'} = P_{B \to B'} [v]_B$</p>
<p>The change of basis matrix is computed as:
$P_{B \to B'} = [I]_{B \to B'} = [[b_1]_{B'} ... [b_n]_{B'}]$</p>
<p>Where $[b_i]_{B'}$ are the coordinates of the old basis vectors in terms of the new basis.</p>
</div>
<div class="cell code_cell"><div class="input_area">
<pre>def change_basis_demonstration():
    # Define two bases
    B = np.array([[1, 0], [0, 1]])  # Standard basis
    Bp = np.array([[1, -1], [1, 1]])  # New basis
    
    # Create change of basis matrix
    P = np.linalg.inv(Bp)  # From new to standard
    P_inverse = Bp        # From standard to new
    
    # Example vector in standard basis
    v_standard = np.array([2, 1])
    
    # Convert to new basis
    v_new = P @ v_standard
    
    # Visualize
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
    
    # Plot in standard basis
    ax1.quiver(0, 0, B[0, 0], B[1, 0], angles='xy', scale_units='xy', scale=1, color='r', label='b1')
    ax1.quiver(0, 0, B[0, 1], B[1, 1], angles='xy', scale_units='xy', scale=1, color='b', label='b2')
    ax1.quiver(0, 0, v_standard[0], v_standard[1], angles='xy', scale_units='xy', scale=1, color='k', label='v')
    ax1.grid(True)
    ax1.set_title('Vector in Standard Basis')
    ax1.legend()
    
    # Plot in new basis
    ax2.quiver(0, 0, Bp[0, 0], Bp[1, 0], angles='xy', scale_units='xy', scale=1, color='r', label="b'1")
    ax2.quiver(0, 0, Bp[0, 1], Bp[1, 1], angles='xy', scale_units='xy', scale=1, color='b', label="b'2")
    ax2.quiver(0, 0, v_new[0], v_new[1], angles='xy', scale_units='xy', scale=1, color='k', label='v')
    ax2.grid(True)
    ax2.set_title('Vector in New Basis')
    ax2.legend()
    
    plt.show()
    
    return P, v_standard, v_new</pre>
</div></div>
<div class="cell code_cell"><div class="input_area">
<pre>P, v_std, v_new = change_basis_demonstration()</pre>
</div><div class="output_area"></div></div>
<div class="cell markdown_cell"><h2 id="2.-Vector-Spaces-as-Geometric-Objects">2. Vector Spaces as Geometric Objects<a class="anchor-link" href="#2.-Vector-Spaces-as-Geometric-Objects">¶</a></h2><p>A vector space is an abstract mathematical structure that exists independently of any particular basis. Think of it as a geometric object that has certain properties (addition and scalar multiplication) but doesn't come with a "built-in" coordinate system.</p>
<h3 id="Key-Insights:">Key Insights:<a class="anchor-link" href="#Key-Insights:">¶</a></h3><ol>
<li><p><strong>Coordinate-Free Nature</strong>:</p>
<ul>
<li>A vector space exists without reference to any particular basis</li>
<li>A basis is like choosing a coordinate system - it's a tool we use to describe points in the space</li>
<li>Different bases are equally valid ways of describing the same space</li>
</ul>
</li>
<li><p><strong>Intrinsic Properties</strong>:
Some properties of a vector space are independent of basis choice:</p>
<ul>
<li>Dimension</li>
<li>Linear independence of vectors</li>
<li>The "shape" of the space</li>
<li>Distance between points (if we have an inner product)</li>
</ul>
</li>
</ol>
<p>Let's visualize how the same vector space can be described using different bases:</p>
</div>
<div class="cell code_cell"><div class="input_area">
<pre>def visualize_same_space_different_bases():
    # Create a set of points in R²
    theta = np.linspace(0, 2*np.pi, 100)
    x = np.cos(theta)
    y = np.sin(theta)
    
    # Create two different bases
    basis1 = np.array([[1, 0], [0, 1]])
    basis2 = np.array([[np.cos(np.pi/4), -np.sin(np.pi/4)], 
                       [np.sin(np.pi/4), np.cos(np.pi/4)]])
    
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
    
    # Plot in standard basis
    ax1.plot(x, y, 'k-', alpha=0.3)
    ax1.quiver(0, 0, basis1[0, 0], basis1[1, 0], angles='xy', scale_units='xy', scale=1, color='r')
    ax1.quiver(0, 0, basis1[0, 1], basis1[1, 1], angles='xy', scale_units='xy', scale=1, color='b')
    ax1.grid(True)
    ax1.set_title('Space in Standard Basis')
    
    # Plot in rotated basis
    ax2.plot(x, y, 'k-', alpha=0.3)
    ax2.quiver(0, 0, basis2[0, 0], basis2[1, 0], angles='xy', scale_units='xy', scale=1, color='r')
    ax2.quiver(0, 0, basis2[0, 1], basis2[1, 1], angles='xy', scale_units='xy', scale=1, color='b')
    ax2.grid(True)
    ax2.set_title('Same Space in Rotated Basis')
    
    plt.show()

visualize_same_space_different_bases()</pre>
</div><div class="output_area"></div></div>
<div class="cell markdown_cell"><h2 id="3.-Matrices-as-Linear-Maps">3. Matrices as Linear Maps<a class="anchor-link" href="#3.-Matrices-as-Linear-Maps">¶</a></h2><p>A matrix can be viewed as a representation of a linear transformation between vector spaces. This is a profound perspective that connects algebraic and geometric thinking.</p>
<h3 id="Mathematical-Framework">Mathematical Framework<a class="anchor-link" href="#Mathematical-Framework">¶</a></h3><p>Given vector spaces $V$ and $W$ with bases $B_V$ and $B_W$, a linear transformation $T: V \to W$ can be represented by a matrix $[T]_{B_V}^{B_W}$ where:</p>
<p>$[T(v)]_{B_W} = [T]_{B_V}^{B_W}[v]_{B_V}$</p>
<p>Key Points:</p>
<ol>
<li>The matrix depends on the choice of bases in both spaces</li>
<li>The transformation itself is basis-independent</li>
<li>Different matrices can represent the same transformation in different bases</li>
</ol>
<p>Let's visualize how a linear transformation acts on a vector space:</p>
</div>
<div class="cell code_cell"><div class="input_area">
<pre>def visualize_linear_transformation():
    # Create a grid of points
    x = np.linspace(-2, 2, 20)
    y = np.linspace(-2, 2, 20)
    X, Y = np.meshgrid(x, y)
    
    # Define a linear transformation
    A = np.array([[2, 1], [-1, 1]])
    
    # Apply transformation to each point
    points = np.column_stack((X.flatten(), Y.flatten()))
    transformed_points = points @ A.T
    
    X_transformed = transformed_points[:, 0].reshape(X.shape)
    Y_transformed = transformed_points[:, 1].reshape(Y.shape)
    
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
    
    # Original space
    ax1.plot(X, Y, 'b.', alpha=0.3, markersize=2)
    ax1.quiver(0, 0, 1, 0, angles='xy', scale_units='xy', scale=1, color='r')
    ax1.quiver(0, 0, 0, 1, angles='xy', scale_units='xy', scale=1, color='b')
    ax1.set_title('Original Space')
    ax1.grid(True)
    
    # Transformed space
    ax2.plot(X_transformed, Y_transformed, 'b.', alpha=0.3, markersize=2)
    transformed_basis_1 = A @ np.array([1, 0])
    transformed_basis_2 = A @ np.array([0, 1])
    ax2.quiver(0, 0, transformed_basis_1[0], transformed_basis_1[1], 
               angles='xy', scale_units='xy', scale=1, color='r')
    ax2.quiver(0, 0, transformed_basis_2[0], transformed_basis_2[1], 
               angles='xy', scale_units='xy', scale=1, color='b')
    ax2.set_title('Transformed Space')
    ax2.grid(True)
    
    plt.show()

visualize_linear_transformation()</pre>
</div><div class="output_area"></div></div>
<div class="cell markdown_cell"><h3 id="Important-Concepts-About-Linear-Maps">Important Concepts About Linear Maps<a class="anchor-link" href="#Important-Concepts-About-Linear-Maps">¶</a></h3><ol>
<li><p><strong>Basis Independence</strong></p>
<ul>
<li>The linear transformation exists independently of any choice of basis</li>
<li>Different matrices represent the same transformation in different bases</li>
<li>If $P$ is a change of basis matrix: $[T]_{\tilde{B}}^{\tilde{C}} = P^{-1}[T]_{B}^{C}P$</li>
</ul>
</li>
<li><p><strong>Eigenvalues and Eigenvectors</strong></p>
<ul>
<li>These are intrinsic properties of the linear transformation</li>
<li>Their values don't depend on the choice of basis</li>
<li>The matrices representing the same transformation in different bases are similar matrices</li>
</ul>
</li>
<li><p><strong>Composition of Linear Maps</strong></p>
<ul>
<li>Matrix multiplication represents composition of linear transformations</li>
<li>$(ST)(v) = S(T(v))$ corresponds to matrix product $[S][T]$</li>
</ul>
</li>
</ol>
<h3 id="Example-Implementation:">Example Implementation:<a class="anchor-link" href="#Example-Implementation:">¶</a></h3></div>
<div class="cell code_cell"><div class="input_area">
<pre>def demonstrate_basis_independence():
    # Define a linear transformation
    T = np.array([[2, 1], [-1, 1]])
    
    # Define a change of basis matrix (rotation by 45 degrees)
    theta = np.pi/4
    P = np.array([[np.cos(theta), -np.sin(theta)], 
                  [np.sin(theta), np.cos(theta)]])
    
    # Compute the transformation matrix in the new basis
    T_new = np.linalg.inv(P) @ T @ P
    
    # Compare eigenvalues
    eig_T = np.linalg.eigvals(T)
    eig_T_new = np.linalg.eigvals(T_new)
    
    print("Original transformation eigenvalues:", eig_T)
    print("Transformed basis eigenvalues:", eig_T_new)
    
    return T, T_new

T, T_new = demonstrate_basis_independence()</pre>
</div><div class="output_area"><pre>Original transformation eigenvalues: [1.5+0.8660254j 1.5-0.8660254j]
Transformed basis eigenvalues: [1.5+0.8660254j 1.5-0.8660254j]
</pre></div></div>
<div class="cell markdown_cell"><h2 id="Key-Takeaways">Key Takeaways<a class="anchor-link" href="#Key-Takeaways">¶</a></h2><ol>
<li><p><strong>Change of Basis</strong></p>
<ul>
<li>Is a fundamental operation in linear algebra</li>
<li>Allows us to represent the same vector in different coordinate systems</li>
<li>Is represented by an invertible matrix</li>
</ul>
</li>
<li><p><strong>Vector Spaces</strong></p>
<ul>
<li>Are geometric objects that exist independently of any basis</li>
<li>Have intrinsic properties that don't depend on choice of basis</li>
<li>Can be described equally well using different bases</li>
</ul>
</li>
<li><p><strong>Linear Transformations</strong></p>
<ul>
<li>Are more fundamental than their matrix representations</li>
<li>Have properties that are independent of basis choice</li>
<li>Can be represented by different matrices in different bases</li>
</ul>
</li>
</ol>
</div>
<div class="cell code_cell"><div class="input_area">
<pre></pre>
</div></div>
</div>
<footer class="footer">
<p>© 2024 Robin Ghyselinck. All Rights Reserved. Any use, reproduction, or distribution of this material without express written permission from the copyright owner is strictly prohibited.</p>
</footer>
</body>
</html>